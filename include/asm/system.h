/*******************************************************************************
	我们知道当前系统使用了特权模式0，
	movl %%esp,%%eax\n\t	将当前的栈顶指针存放进入eax
	pushl $0x17	17为00010111	这个为段选择符，表示权限为3，在局部描述符中，索引为2
	pushfl 将eflags 入栈
	pushl $0x0f f为00001111 为代码段选择符，表示权限为3，在局部描述符中，
	iret 指令会有如下动作，当返回的cs和返回cs的权限一致时，不会弹出ss,esp,当cs和返回的
	cs的权限不一致时会弹出ss，esp，在这里当前cs的权限为0，返回的cs为f，权限为3，因此
	此处权限不一致会弹出ss和esp
	movl $0x17,%%eax，设置数据段的描述符，此时系统继续运行吓一跳指令
*******************************************************************************/
#define move_to_user_mode() \
__asm__ ("movl %%esp,%%eax\n\t" \
	"pushl $0x17\n\t" \
	"pushl %%eax\n\t" \
	"pushfl\n\t" \
	"pushl $0x0f\n\t" \
	"pushl $1f\n\t" \
	"iret\n" \
	"1:\tmovl $0x17,%%eax\n\t" \
	"movw %%ax,%%ds\n\t" \
	"movw %%ax,%%es\n\t" \
	"movw %%ax,%%fs\n\t" \
	"movw %%ax,%%gs" \
	:::"ax")

/*******************************************************************************
	sti允许中断
	cli禁止中断
	这两个指令必须在内核模式下执行，不能再用户模式下执行
*******************************************************************************/
#define sti() __asm__ ("sti"::)
#define cli() __asm__ ("cli"::)

/*******************************************************************************
	nop
*******************************************************************************/
#define nop() __asm__ ("nop"::)

/*******************************************************************************
	中断返回
*******************************************************************************/
#define iret() __asm__ ("iret"::)


/*******************************************************************************
	gcc的内联汇编函数格式
	asm("assemble": output : input : 受影响的寄存器)
	m 表示内存操作数
	i 表示理解操作数
	a 使用寄存器eax
	b 使用寄存器ebx
	c 使用寄存器ecx
	d 使用寄存器edx
	S 使用esi
	D 使用edi
	q 动态分配字节可寻址的寄存器
	r 使用任意动态分配的寄存器
	A 使用eax和edx联合的64位寄存器
	o 内存操作数，但前提是此地址是可偏移的，向地址添加一个小偏移会给出一个有效地址

	如下程序
	没有输出项，
	输入项为
	"i" ((short) (0x8000+(dpl<<13)+(type<<8)))
	表示是一个立即数，编号为%0
	"o" (*((char *) (gate_addr))) 表示gate_addr的地址
	"o" (*(4+(char *) (gate_addr))), 表示gate_addr + 4的地址
	"d" ((char *) (addr)), 表示将addr存放在edx
	"a" (0x00080000) 表示将0x00080000存放在adx
	因此下面的宏定义为
	+----------+---+-----------+---+---+-----------+--------+--------------+-----------+----------+
	| H 16bits | P | DPL(2bit) | 0 | D | 3bit type | 3bit 0 | 5bit Reserve | 16bits CS | L 16bits |
	+----------+---+-----------+---+---+-----------+--------+--------------+-----------+----------+
	|          | 1 |   00      | 0 | 1 |    110    |   000  |              |     8     |          |
	+----------+---+-----------+---+---+-----------+--------+--------------+-----------+----------+
	将addr的低16位放在ex中，由于eax的初始值为0x00080000因此这条语句执行完毕后
	eax的低16位将会存放addr的低16位地址
	然后将((short) (0x8000+(dpl<<13)+(type<<8)))为第0个参数用%0表示，
	将其存放在dx,也就是edx的低16位，此时edx的高
	16位仍然为addr的高16位地址
	将eax的值存放在gate_addr处
	将edx的值存放在gate_addr + 4处，从而构造一个异常表
*******************************************************************************/
#define _set_gate(gate_addr,type,dpl,addr) \
__asm__ ("movw %%dx,%%ax\n\t" \
	"movw %0,%%dx\n\t" \
	"movl %%eax,%1\n\t" \
	"movl %%edx,%2" \
	: \
	: "i" ((short) (0x8000+(dpl<<13)+(type<<8))), \
	"o" (*((char *) (gate_addr))), \
	"o" (*(4+(char *) (gate_addr))), \
	"d" ((char *) (addr)),\
	"a" (0x00080000))

/*******************************************************************************
	设置中断门，DPL=0表示特权模式，
	type = 14 = 1110 表示中断门
*******************************************************************************/
#define set_intr_gate(n,addr) \
	_set_gate(&idt[n],14,0,addr)

/*******************************************************************************
 	idt是全局的idt数组，定义在head.s汇编程序，保留了256*8个空间
 	typedef struct desc_struct {
 		unsigned long a,b;
 	} desc_table[256];
 	设置完成之后，当n产生中断后就会执行addr地址的函数
 	如下，DPL= 0 表示特权模式
 	type = 15 = 1111表示陷阱门
*******************************************************************************/
#define set_trap_gate(n,addr) \
	_set_gate(&idt[n],15,0,addr)

/*******************************************************************************
	系统门
	type = 15 = 1111
	DPL = 3, 表示用户模式
*******************************************************************************/
#define set_system_gate(n,addr) \
	_set_gate(&idt[n],15,3,addr)

/*******************************************************************************
	下面的代码，这个我搜索了全部的代码，没有找到引用的地方
*******************************************************************************/
#define _set_seg_desc(gate_addr,type,dpl,base,limit) {\
	*(gate_addr) = ((base) & 0xff000000) | \
		(((base) & 0x00ff0000)>>16) | \
		((limit) & 0xf0000) | \
		((dpl)<<13) | \
		(0x00408000) | \
		((type)<<8); \
	*((gate_addr)+1) = (((base) & 0x0000ffff)<<16) | \
		((limit) & 0x0ffff); }

/*******************************************************************************
	设置任务段，局部段描述符，我们先看一个例子，这个例子是全局段描述符
	gdt:
	.word	0,0,0,0				# dummy

	.word	0x07FF				# 8Mb - limit=2047 (2048*4096=8Mb)
	.word	0x0000				# base address=0
	.word	0x9A00				# code read/exec
	.word	0x00C0				# granularity=4096, 386

	.word	0x07FF				# 8Mb - limit=2047 (2048*4096=8Mb)
	.word	0x0000				# base address=0
	.word	0x9200				# data read/write
	.word	0x00C0				# granularity=4096, 386
    n 表示全局描述符n所对应的地址
    addr 表示状态段/局部段所在的内存地址
    type 类型
    由内联汇编的知识我们知道如下信息
	1 没有输出项
	2 有输入项
	3 没有影响的寄存器列表
	存储器的段描述符如下一共64位
	| 段基址[31:24] | G/DB/L/AVL/段界限[19:16] | p/DPL(2bits)/s/TYPE(4bits) | 段基址[23:16] |
	|                 段基址[15:0]             |                 段界限【15-0】             |
	以上为一个段描述符结构，右下为低位，左上为高位
	参数如下
	%0 addr存放在eax寄存器中
	%1 描述符n的起始地址
	%2 描述符n的起始地址+2
	%3 描述符n的起始地址+4
	%4 描述符n的起始地址+5
	%5 描述符n的起始地址+6
	%6 描述符n的地址地址+7
	
	104时TSS段的大小，我们知道如果是一个局部段，则大小为8个字节，这里使用最大的
	将104存放在参数1中，也就是n的起始地址中，movw表示一个字，16位
	将eax中的低16位存放在参数2，也就n + 2地址，如上图为段基址[15:0]
	将exx右移16位，也就是addr的高16位存放在ax中，
	将al存放在段基址[23:16] 
	将类型存放在n + 5中，如上图为 p/DPL(2bits)/s/TYPE(4bits)
	将ah存放在段基址[31:24]
*******************************************************************************/
#define _set_tssldt_desc(n,addr,type) \
__asm__ ("movw $104,%1\n\t" \
	"movw %%ax,%2\n\t" \
	"rorl $16,%%eax\n\t" \
	"movb %%al,%3\n\t" \
	"movb $" type ",%4\n\t" \
	"movb $0x00,%5\n\t" \
	"movb %%ah,%6\n\t" \
	"rorl $16,%%eax" \
	::"a" (addr), "m" (*(n)), "m" (*(n+2)), "m" (*(n+4)), \
	 "m" (*(n+5)), "m" (*(n+6)), "m" (*(n+7)) \
	)

/*******************************************************************************
	在n地址处，设置一个TSS段描述符或者LDT描述符
*******************************************************************************/
#define set_tss_desc(n,addr) _set_tssldt_desc(((char *) (n)),((int)(addr)),"0x89")
#define set_ldt_desc(n,addr) _set_tssldt_desc(((char *) (n)),((int)(addr)),"0x82")

